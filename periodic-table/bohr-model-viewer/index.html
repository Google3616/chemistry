<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Bohr Model</title>
  <link rel="icon" href="https://www.svgrepo.com/show/9768/atom.svg" />
  <style>
    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --text-primary: #e8e8e8;
      --accent-color: #4d80e4;
      --nucleus-color: #e94560;
      --electron-color: #4d80e4;
      --shell-color: rgba(255, 255, 255, 0.2);
      --s-orbital: #4d80e4;
      --p-orbital: #46e069;
      --d-orbital: #e7d40b;
      --f-orbital: #e94560;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background-color: var(--bg-primary);
      margin: 0;
      padding: 0;
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      text-align: center;
      padding: 20px;
      width: 100%;
    }

    h1 {
      margin: 0;
      font-size: 2.5rem;
    }

    .element-symbol {
      font-size: 4rem;
      font-weight: bold;
    }

    .element-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }

    .atomic-details {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }

    .detail-box {
      background-color: var(--bg-secondary);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
    }

    .detail-box h3 {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.7;
    }

    .detail-box p {
      margin: 5px 0 0;
      font-size: 1.2rem;
      font-weight: bold;
    }

    #bohr-model {
      position: relative;
      margin: 20px auto;
      width: 500px;
      height: 500px;
    }

    .nucleus {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      background-color: var(--nucleus-color);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 0 20px rgba(233, 69, 96, 0.6);
      z-index: 2;
      font-weight: bold;
      animation: pulse 4s infinite alternate;
    }

    .shell {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 2px solid var(--shell-color);
      z-index: 1;
    }

    .electron {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: var(--electron-color);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px var(--electron-color);
      z-index: 3;
    }

    .s-orbital {
      background-color: var(--s-orbital);
      box-shadow: 0 0 8px var(--s-orbital);
    }

    .p-orbital {
      background-color: var(--p-orbital);
      box-shadow: 0 0 8px var(--p-orbital);
    }

    .d-orbital {
      background-color: var(--d-orbital);
      box-shadow: 0 0 8px var(--d-orbital);
    }

    .f-orbital {
      background-color: var(--f-orbital);
      box-shadow: 0 0 8px var(--f-orbital);
    }

    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
      padding: 20px;
      background-color: var(--bg-secondary);
      border-radius: 10px;
      width: 80%;
      max-width: 500px;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      width: 100%;
    }

    .speed-control label {
      min-width: 100px;
    }

    input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .switch-container {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }

    .switch {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--accent-color);
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    .element-search {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    .element-search input {
      padding: 8px 12px;
      border-radius: 5px;
      border: none;
      outline: none;
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .element-search button {
      background-color: var(--accent-color);
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 15px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .element-search button:hover {
      background-color: #3a6ad4;
    }

    .orbital-info {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 15px;
    }

    .orbital-type {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .orbital-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .s-orbital-dot {
      background-color: var(--s-orbital);
      box-shadow: 0 0 5px var(--s-orbital);
    }

    .p-orbital-dot {
      background-color: var(--p-orbital);
      box-shadow: 0 0 5px var(--p-orbital);
    }

    .d-orbital-dot {
      background-color: var(--d-orbital);
      box-shadow: 0 0 5px var(--d-orbital);
    }

    .f-orbital-dot {
      background-color: var(--f-orbital);
      box-shadow: 0 0 5px var(--f-orbital);
    }

    .electron-config {
      background-color: var(--bg-secondary);
      padding: 10px 20px;
      border-radius: 10px;
      margin-top: 20px;
      font-family: monospace;
      font-size: 1.2rem;
      letter-spacing: 1px;
    }

    /* Animations */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 20px rgba(233, 69, 96, 0.4);
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        transform: translate(-50%, -50%) scale(1.05);
      }
    }

    @media (max-width: 600px) {
      #bohr-model {
        width: 300px;
        height: 300px;
      }
      
      .nucleus {
        width: 50px;
        height: 50px;
      }
      
      .electron {
        width: 8px;
        height: 8px;
      }
      
      .controls {
        width: 90%;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Interactive Bohr Model</h1>
  </div>

  <div class="element-info">
    <div class="element-symbol" id="elementSymbol">?</div>
    <h2 id="elementName">Loading...</h2>
    <div class="atomic-details">
      <div class="detail-box">
        <h3>Atomic Number</h3>
        <p id="atomicNumber">-</p>
      </div>
      <div class="detail-box">
        <h3>Atomic Mass</h3>
        <p id="atomicMass">-</p>
      </div>
      <div class="detail-box">
        <h3>Period</h3>
        <p id="period">-</p>
      </div>
      <div class="detail-box">
        <h3>Group</h3>
        <p id="group">-</p>
      </div>
    </div>
  </div>

  <div id="bohr-model"></div>

  <div class="electron-config" id="electronConfig">Electron Configuration: -</div>

  <div class="orbital-info">
    <div class="orbital-type">
      <div class="orbital-dot s-orbital-dot"></div>
      <span>s orbital</span>
    </div>
    <div class="orbital-type">
      <div class="orbital-dot p-orbital-dot"></div>
      <span>p orbital</span>
    </div>
    <div class="orbital-type">
      <div class="orbital-dot d-orbital-dot"></div>
      <span>d orbital</span>
    </div>
    <div class="orbital-type">
      <div class="orbital-dot f-orbital-dot"></div>
      <span>f orbital</span>
    </div>
  </div>

  <div class="controls">
    <div class="speed-control">
      <label for="speedControl">Electron Speed:</label>
      <input type="range" id="speedControl" min="0.1" max="2" step="0.1" value="1">
    </div>
    <div class="switch-container">
      <div class="switch">
        <span>Rotation</span>
        <label class="toggle-switch">
          <input type="checkbox" id="rotationToggle" checked>
          <span class="slider"></span>
        </label>
      </div>
      <div class="switch">
        <span>Color by Orbital</span>
        <label class="toggle-switch">
          <input type="checkbox" id="colorToggle" checked>
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </div>

  <script>
    function fixUrl() {
    let url = new URL(window.location.href);
    if (url.pathname.endsWith(".html")) {
        url.pathname = url.pathname.replace(".html", ""); // Remove .html
        window.location.href = url.toString(); // Navigate to new URL
    }
    }
    fixUrl();
    // Element data store
    let elementData = null;
    let electrons = [];
    let shellElements = [];
    let animationSpeed = 1;
    let rotationEnabled = true;
    let colorByOrbital = true;
    let animationFrameId = null;

    // Electron configuration patterns
    const orbitalPatterns = {
      s: 2,
      p: 6,
      d: 10,
      f: 14
    };

    const shellCapacities = [2, 8, 18, 32, 32, 32, 32];
    const shellRadii = [60, 100, 140, 180, 220, 260, 300];
    
    // Configuration order (aufbau principle)
    const configOrder = [
      "1s", "2s", "2p", "3s", "3p", "4s", "3d", "4p", "5s", "4d", "5p", "6s", 
      "4f", "5d", "6p", "7s", "5f", "6d", "7p"
    ];

    // Extract element parameter from URL
    function getElementFromUrl() {
      // Try modern URL API first
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const elementParam = urlParams.get('element');
        if (elementParam) return elementParam;
      } catch (e) {
        // Fallback for older browsers
        const paramString = window.location.search.substring(1);
        const params = paramString.split('&');
        for (let i = 0; i < params.length; i++) {
          const pair = params[i].split('=');
          if (pair[0] === 'element') {
            return decodeURIComponent(pair[1]);
          }
        }
      }

      // Check for path parameter like /element/hydrogen
      const pathParts = window.location.pathname.split('/');
      for (let i = 0; i < pathParts.length; i++) {
        if (pathParts[i].toLowerCase() === 'element' && i + 1 < pathParts.length) {
          return pathParts[i + 1];
        }
      }

      // Default element if none specified
      return 'hydrogen';
    }

    // Fetch element data
    async function fetchElementData(elementIdentifier) {
      try {
        // Try the first API
        const response = await fetch(`https://periodic-table-elements-info.herokuapp.com/elements`);
        
        if (!response.ok) {
          throw new Error('Primary API failed');
        }
        
        const data = await response.json();
        
        // Find the element by name or symbol
        const searchTerm = elementIdentifier.toLowerCase();
        const element = data.find(el => 
          el.name.toLowerCase() === searchTerm || 
          el.symbol.toLowerCase() === searchTerm ||
          el.number.toString() === searchTerm
        );
        
        if (element) {
          return element;
        } else {
          throw new Error('Element not found in first API');
        }
      } catch (error) {
        console.log('Trying backup source...');
        
        try {
          // Try the backup API
          const response = await fetch('https://raw.githubusercontent.com/Bowserinator/Periodic-Table-JSON/master/PeriodicTableJSON.json');
          
          if (!response.ok) {
            throw new Error('Backup API failed');
          }
          
          const data = await response.json();
          
          // Find the element by name or symbol
          const searchTerm = elementIdentifier.toLowerCase();
          const element = data.elements.find(el => 
            el.name.toLowerCase() === searchTerm || 
            el.symbol.toLowerCase() === searchTerm ||
            el.number.toString() === searchTerm
          );
          
          if (element) {
            return element;
          } else {
            throw new Error('Element not found in backup API');
          }
        } catch (secondError) {
          console.error('Both APIs failed:', secondError);
          
          // If all APIs fail, use hydrogen as fallback
          return getFallbackElement();
        }
      }
    }

    function getFallbackElement() {
      return {
        name: "Hydrogen",
        symbol: "H",
        number: 1,
        atomic_mass: 1.008,
        period: 1,
        group: 1,
        electron_configuration: "1s1"
      };
    }

    // Calculate electron configuration
    function calculateElectronConfiguration(atomicNumber) {
      if (elementData.electron_configuration) {
        return elementData.electron_configuration;
      }
      
      // If API doesn't provide electron configuration, calculate it
      let remaining = atomicNumber;
      let config = [];
      
      for (const orbital of configOrder) {
        const shellNumber = parseInt(orbital[0]);
        const orbitalType = orbital[1];
        const maxElectrons = orbitalPatterns[orbitalType];
        
        if (remaining <= 0) break;
        
        const electronsInOrbital = Math.min(remaining, maxElectrons);
        config.push(`${shellNumber}${orbitalType}${electronsInOrbital}`);
        remaining -= electronsInOrbital;
      }
      
      return config.join(' ');
    }

    // Update element information display
    function updateElementInfo() {
      if (!elementData) return;
      
      document.getElementById('elementSymbol').textContent = elementData.symbol;
      document.getElementById('elementName').textContent = elementData.name;
      document.getElementById('atomicNumber').textContent = elementData.number;
      document.getElementById('atomicMass').textContent = parseFloat(elementData.atomic_mass).toFixed(3);
      document.getElementById('period').textContent = elementData.period || 'N/A';
      document.getElementById('group').textContent = elementData.group || 'N/A';
      
      const electronConfig = calculateElectronConfiguration(elementData.number);
      document.getElementById('electronConfig').textContent = `Electron Configuration: ${electronConfig}`;
      
      // Update page title
      document.title = `${elementData.name} (${elementData.symbol}) - Bohr Model`;
    }

    // Create Bohr model visualization
    function createBohrModel() {
      const bohrModel = document.getElementById('bohr-model');
      bohrModel.innerHTML = '';
      electrons = [];
      shellElements = [];
      
      // Create nucleus
      const nucleus = document.createElement('div');
      nucleus.className = 'nucleus';
      nucleus.textContent = elementData.symbol;
      bohrModel.appendChild(nucleus);
      
      // Parse electron configuration
      const electronConfig = calculateElectronConfiguration(elementData.number);
      const configParts = electronConfig.split(' ');
      
      // Create shells
      let shellElectrons = Array(7).fill(0);
      
      // Count electrons per shell from configuration
      configParts.forEach(part => {
        const shellNumber = parseInt(part[0]) - 1; // 0-indexed array
        const orbitalType = part[1];
        const electronsInOrbital = parseInt(part.slice(2));
        
        shellElectrons[shellNumber] += electronsInOrbital;
      });
      
      // Create shell circles
      for (let i = 0; i < shellElectrons.length; i++) {
        const electrons = shellElectrons[i];
        if (electrons === 0) continue;
        
        const shellRadius = shellRadii[i];
        const shell = document.createElement('div');
        shell.className = 'shell';
        shell.style.width = `${shellRadius * 2}px`;
        shell.style.height = `${shellRadius * 2}px`;
        bohrModel.appendChild(shell);
        shellElements.push(shell);
      }
      
      // Create electrons and place them on shells
      let electronCounter = 0;
      configParts.forEach(part => {
        const shellNumber = parseInt(part[0]) - 1; // 0-indexed array
        const orbitalType = part[1];
        const electronsInOrbital = parseInt(part.slice(2));
        const shellRadius = shellRadii[shellNumber];
        
        for (let i = 0; i < electronsInOrbital; i++) {
          const electron = document.createElement('div');
          electron.className = `electron ${orbitalType}-orbital`;
          
          // Calculate angle for this electron to distribute them evenly
          const electronsInShell = shellElectrons[shellNumber];
          const angle = (360 / electronsInShell) * (electronCounter % electronsInShell);
          const angleRadians = (angle * Math.PI) / 180;
          
          // Initial position
          const x = 250 + shellRadius * Math.cos(angleRadians);
          const y = 250 + shellRadius * Math.sin(angleRadians);
          
          electron.style.left = `${x}px`;
          electron.style.top = `${y}px`;
          
          // Store electron data for animation
          electrons.push({
            element: electron,
            shellRadius,
            shellNumber,
            angle,
            orbitalType,
            speed: 1 - (shellNumber * 0.1) // Outer shells move slower
          });
          
          bohrModel.appendChild(electron);
          electronCounter++;
        }
      });
      
      // Start animation
      animateElectrons();
    }

    // Animate electrons
    function animateElectrons() {
      let lastTimestamp = 0;
      
      function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        
        const elapsed = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        
        if (rotationEnabled) {
          electrons.forEach(electron => {
            // Update angle based on speed and time elapsed
            electron.angle += (0.4 * electron.speed * animationSpeed * elapsed / 16);
            if (electron.angle >= 360) electron.angle -= 360;
            
            const angleRadians = (electron.angle * Math.PI) / 180;
            
            // Calculate new position
            const x = 250 + electron.shellRadius * Math.cos(angleRadians);
            const y = 250 + electron.shellRadius * Math.sin(angleRadians);
            
            // Update electron position
            electron.element.style.left = `${x}px`;
            electron.element.style.top = `${y}px`;
            
            // Apply or remove orbital-based coloring
            if (colorByOrbital) {
              electron.element.className = `electron ${electron.orbitalType}-orbital`;
            } else {
              electron.element.className = 'electron';
            }
          });
        }
        
        animationFrameId = requestAnimationFrame(animate);
      }
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      animationFrameId = requestAnimationFrame(animate);
    }

    // Event listeners for controls
    function setupControls() {
      // Speed control
      const speedControl = document.getElementById('speedControl');
      speedControl.addEventListener('input', function() {
        animationSpeed = parseFloat(this.value);
      });
      
      // Rotation toggle
      const rotationToggle = document.getElementById('rotationToggle');
      rotationToggle.addEventListener('change', function() {
        rotationEnabled = this.checked;
      });
      
      // Color toggle
      const colorToggle = document.getElementById('colorToggle');
      colorToggle.addEventListener('change', function() {
        colorByOrbital = this.checked;
      });
      
    }

    // Initialize the application
    async function init() {
      const elementIdentifier = getElementFromUrl();
      elementData = await fetchElementData(elementIdentifier);
      
      updateElementInfo();
      createBohrModel();
      setupControls();
    }

    // Start the application when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>